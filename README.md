# Toto App

## Полезные ссылки

- [Оценка в Notion](https://www.notion.so/173bfe895c7a4caea569212af37c55ca)
- [Дизайн figma](https://www.figma.com/file/3madwOvusyVd3H3tDGHZ8c/%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D1%8F-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0-%D0%9F%D0%B8%D1%86%D1%86%D0%B0-%D0%A2%D0%BE-%D0%A2%D0%BE?node-id=629%3A83720)

## Структура проекта

- **resources** - темы, иконки, в дальнейшем возможно константы для ui
- **core** - ядро, которое делится на presentation, domain и data (см. _Core-часть_)
- **injection** - настройка Dependency Injection

!!! Импорт пакетов только с nullsafty и портами для всех платформ

### Presentation

Presentation делится на две составляющие: часть UI и часть бизнес-логики компонента (BLoC).

**BLoC** - это логика _представления_ для конкретной сущности View, имеющая эвенты (event) на вход и состояние (state) на выход. Обычно event это [sink](https://api.dart.dev/stable/2.9.1/dart-core/Sink-class.html), а state - [stream](https://dart.dev/tutorials/language/streams). Реализуется посредством [этого пакета](https://pub.dev/packages/flutter_bloc).

**View** - часть представления, которая делегирует всю логику (в т.ч. навигацию) BLoC'у. Представляет из себя отдельный экран, который инициализируется посредством внутреннего роутинга приложения (директория screens).
Каждый экран или виджет храниться в отдельной папке, если:

- Работает с bloc
- Должен по разному рендерится на разных платформах

Для определения таких виджетов используется `Decider`.

Знает о domain-сущностях, не знает о data.

- **router** - роутинг приложения, содержит виджет навигатора и BLoC
- **screens** - каждый конкретный экран приложения, содержит лейаут и BLoC
- **widgets** - содержит переиспользуемые всем приложением компоненты

### Domain

Часть бизнес-логики приложения. Не зависит ни от части представления, ни от части данных.

Принимает на вход Entity, при необходимости преобразует данные для соответствия бизнес-логике, и отдает Entity.

Также содержит юзкейсы, которые являются прослойкой между слоем бизнес-логики и data-слоем.

### Data

Через интерфейсы DAO (data access object) и API services оперирует моделями данных.

Часть repository представляет собой некий пограничный слой, который дёргает DAO или API, ловит ошибки и возвращает данных в понятном для domain виде.

Не знает о presentation, но использует модели данных из domain. По сути просто "пережёвывает" данные и отдает domain-части.

## Навигация

Навигация реализуется через утилиту [Navigator 2.0](https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade).

Стейт-менеджер - BLoC, как и для экранов приложения.

Намерение перейти на конкретный экран - event, текущий стек экранов - state.

Последовательность действий для добавления экрана:

1. Добавить новый event в RouterEvent и перегенерировать freezed
2. Добавить обработчик для перехода внутри RouterBloc
3. Добавить в класс ScreenProvider новое поле, задать id роута и добавить сам экран

### Генерация кода

Код генерируется через build runner для пакетов freezed, injectable, hive (для адаптеров) и graphql-запросов.

Для генерации graphql-запросов следует в папке lib/core/data/network/models создать .graphql-файл, добавить свой запрос и запустить генерацию.

Запуск билд раннера: `flutter pub run build_runner watch --delete-conflicting-outputs` для периодического ребилда или `flutter pub run build_runner build --delete-conflicting-outputs`

#### Генерация DI

Чтобы добавить фабрику/синглтон, нужно:

1. Пометить класс аннотацией @Injectable()/@Singleton(). В случае, если класс реализует интерфейс, в аннотации можно указать, какой именно класс будет сгенерирован:

```
abstract class SampleClass {
    ...
}


@Injectable(as: SampleClass)

class SampleClassImpl implements SampleClass {
    ...
}
```

2. Запустить кодогенерацию.

Также добавить зависимость можно вручную. Например:

```
getIt.registerFactory<SampleClass>(() => SampleClass());
```
